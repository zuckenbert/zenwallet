# MVP 1.3.0 - ZenWallet 100% Functional

> **For Agents:** REQUIRED SUB-SKILL: Use executing-plans to implement this plan task-by-task.

**Goal:** Make ZenWallet fully functional with Solana blockchain, supporting both internal wallets and external wallets (Phantom/Solflare) for swaps, sends, and transaction history.

**Architecture:** The core issue is that `getKeypair()` returns null for external wallets (Phantom/Solflare), breaking all transaction signing. We will:
1. Create a unified transaction signing service that detects wallet type and routes to appropriate signing method
2. Implement transaction history using Helius API with fallback to Solana RPC
3. Add retry logic and RPC fallbacks for resilience

**Tech Stack:**
- React 19 + TypeScript + Vite
- Zustand for state management
- @solana/web3.js + @solana/wallet-adapter-react
- Jupiter API for swaps
- Helius API for enhanced RPC and transaction history
- Vitest for testing

**Global Prerequisites:**
- Environment: macOS, Node.js 18+
- Tools: npm 7+, git
- Access: Helius API key (optional but recommended for SPL tokens and history)
- State: Clean git working tree on `main` branch

**Verification before starting:**
```bash
cd /Users/lucasbertol/zenwallet
node --version    # Expected: v18.x.x or higher
npm --version     # Expected: 7.x.x or higher
git status        # Expected: clean working tree
npm run build     # Expected: Build succeeds
```

---

## Architecture Diagram

```
+------------------+     +-------------------+     +------------------+
|   useSwap.ts     |     |  useSend.ts       |     | useHistory.ts    |
|   useTransaction |---->|  (NEW hook)       |---->| (NEW hook)       |
+--------+---------+     +--------+----------+     +--------+---------+
         |                        |                         |
         v                        v                         v
+--------+------------------------+-------------------------+---------+
|                    TransactionService (NEW)                         |
|  - signTransaction(tx, walletType) -> Promise<VersionedTransaction> |
|  - sendTransaction(signedTx) -> Promise<string>                     |
|  - detectWalletType() -> 'internal' | 'external'                    |
+---------------------------------+-----------------------------------+
                                  |
         +------------------------+------------------------+
         |                                                 |
         v                                                 v
+--------+---------+                            +----------+----------+
| Internal Wallet  |                            | External Wallet     |
| (Keypair signing)|                            | (Adapter signing)   |
| getKeypair()     |                            | useWallet().sign..  |
+------------------+                            +---------------------+

+------------------+     +-------------------+
| HeliusService    |     | RPC Fallback      |
| (NEW)            |---->| connection.ts     |
| - getHistory()   |     | - getConnection() |
| - getAssets()    |     | - fallback RPCs   |
+------------------+     +-------------------+
```

---

## Batch 1: Core Transaction Signing Service (Tasks 1-5)

This batch creates the foundation for unified transaction signing that works with both internal and external wallets.

### Task 1: Create Transaction Types

**File:** `/Users/lucasbertol/zenwallet/src/types/transaction.ts`
**Action:** Create

**New Code:**
```typescript
import { VersionedTransaction, Transaction } from '@solana/web3.js';

export type WalletType = 'internal' | 'external';

export interface TransactionContext {
  walletType: WalletType;
  publicKey: string;
}

export interface SignedTransactionResult {
  transaction: VersionedTransaction | Transaction;
  signature?: string;
}

export interface TransactionHistoryItem {
  signature: string;
  timestamp: number;
  type: 'send' | 'receive' | 'swap' | 'unknown';
  status: 'success' | 'failed' | 'pending';
  amount?: number;
  symbol?: string;
  mint?: string;
  from?: string;
  to?: string;
  fee?: number;
  description?: string;
}

export interface TransactionHistoryResponse {
  transactions: TransactionHistoryItem[];
  hasMore: boolean;
  cursor?: string;
}

export interface SendTransactionParams {
  toAddress: string;
  amount: number;
  mint: string;
  decimals: number;
  isNative: boolean;
}

export interface SwapTransactionParams {
  quoteResponse: unknown;
  userPublicKey: string;
}
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/types/transaction.ts
```
**Expected Output:**
```
(no output - successful compilation)
```

**If Task Fails:**
1. **TypeScript error:**
   - Check: Import paths are correct
   - Fix: Ensure @solana/web3.js is installed
   - Rollback: `rm src/types/transaction.ts`

---

### Task 2: Create Transaction Service - Core Structure

**File:** `/Users/lucasbertol/zenwallet/src/lib/solana/transactionService.ts`
**Action:** Create

**New Code:**
```typescript
import {
  VersionedTransaction,
  Transaction,
  Connection,
  PublicKey,
  Keypair,
  sendAndConfirmTransaction,
  TransactionSignature,
} from '@solana/web3.js';
import { WalletContextState } from '@solana/wallet-adapter-react';
import { getConnection } from './connection';
import { WalletType, SignedTransactionResult } from '@/types/transaction';

// Retry configuration
const MAX_RETRIES = 3;
const RETRY_DELAY_MS = 1000;
const CONFIRMATION_TIMEOUT_MS = 60000;

/**
 * Sleep utility for retry delays
 */
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Retry wrapper for async operations
 */
async function withRetry<T>(
  operation: () => Promise<T>,
  maxRetries: number = MAX_RETRIES,
  delayMs: number = RETRY_DELAY_MS
): Promise<T> {
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error) {
      lastError = error as Error;
      const isRateLimited =
        lastError.message.includes('429') ||
        lastError.message.includes('rate limit') ||
        lastError.message.includes('Too many requests');

      if (attempt < maxRetries) {
        const delay = isRateLimited ? delayMs * attempt * 2 : delayMs * attempt;
        console.warn(
          `Attempt ${attempt}/${maxRetries} failed: ${lastError.message}. Retrying in ${delay}ms...`
        );
        await sleep(delay);
      }
    }
  }

  throw lastError;
}

/**
 * Sign transaction with internal keypair
 */
export async function signWithKeypair(
  transaction: VersionedTransaction,
  keypair: Keypair
): Promise<VersionedTransaction> {
  transaction.sign([keypair]);
  return transaction;
}

/**
 * Sign transaction with external wallet adapter
 */
export async function signWithWalletAdapter(
  transaction: VersionedTransaction,
  walletAdapter: WalletContextState
): Promise<VersionedTransaction> {
  if (!walletAdapter.signTransaction) {
    throw new Error('Wallet does not support transaction signing');
  }

  const signedTx = await walletAdapter.signTransaction(transaction);
  return signedTx as VersionedTransaction;
}

/**
 * Send and confirm transaction with retry logic
 */
export async function sendAndConfirmWithRetry(
  connection: Connection,
  transaction: VersionedTransaction,
  options?: {
    skipPreflight?: boolean;
    maxRetries?: number;
  }
): Promise<TransactionSignature> {
  const { skipPreflight = true, maxRetries = MAX_RETRIES } = options || {};

  return withRetry(async () => {
    const rawTransaction = transaction.serialize();

    const signature = await connection.sendRawTransaction(rawTransaction, {
      skipPreflight,
      maxRetries: 3,
    });

    // Confirm transaction
    const latestBlockHash = await connection.getLatestBlockhash();
    const confirmation = await connection.confirmTransaction(
      {
        blockhash: latestBlockHash.blockhash,
        lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,
        signature,
      },
      'confirmed'
    );

    if (confirmation.value.err) {
      throw new Error(`Transaction failed: ${JSON.stringify(confirmation.value.err)}`);
    }

    return signature;
  }, maxRetries);
}

/**
 * Unified transaction signing based on wallet type
 */
export async function signTransaction(
  transaction: VersionedTransaction,
  walletType: WalletType,
  keypair: Keypair | null,
  walletAdapter: WalletContextState | null
): Promise<VersionedTransaction> {
  if (walletType === 'internal') {
    if (!keypair) {
      throw new Error('Internal wallet requires keypair for signing');
    }
    return signWithKeypair(transaction, keypair);
  } else {
    if (!walletAdapter) {
      throw new Error('External wallet requires wallet adapter for signing');
    }
    return signWithWalletAdapter(transaction, walletAdapter);
  }
}

/**
 * Complete transaction flow: sign and send with retry
 */
export async function executeTransaction(
  transaction: VersionedTransaction,
  walletType: WalletType,
  keypair: Keypair | null,
  walletAdapter: WalletContextState | null
): Promise<{ signature: string; status: 'success' | 'failed'; error?: string }> {
  try {
    const connection = getConnection();

    // Sign the transaction
    const signedTx = await signTransaction(
      transaction,
      walletType,
      keypair,
      walletAdapter
    );

    // Send and confirm
    const signature = await sendAndConfirmWithRetry(connection, signedTx);

    return { signature, status: 'success' };
  } catch (error) {
    console.error('Transaction execution failed:', error);
    return {
      signature: '',
      status: 'failed',
      error: (error as Error).message,
    };
  }
}
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/lib/solana/transactionService.ts
```
**Expected Output:**
```
(no output - successful compilation)
```

**If Task Fails:**
1. **Import error for WalletContextState:**
   - Check: `npm list @solana/wallet-adapter-react`
   - Fix: Package should already be installed
   - Rollback: `rm src/lib/solana/transactionService.ts`

---

### Task 3: Add RPC Fallback Support to Connection

**File:** `/Users/lucasbertol/zenwallet/src/lib/solana/connection.ts`
**Action:** Modify (lines 1-36)

**Current Code:**
```typescript
import { Connection, clusterApiUrl } from '@solana/web3.js';

const HELIUS_API_KEY = import.meta.env.VITE_HELIUS_API_KEY || '';
const NETWORK = import.meta.env.VITE_SOLANA_NETWORK || 'devnet';

function getRpcUrl(): string {
  if (HELIUS_API_KEY) {
    const cluster = NETWORK === 'mainnet-beta' ? 'mainnet' : 'devnet';
    return `https://${cluster}.helius-rpc.com/?api-key=${HELIUS_API_KEY}`;
  }
  return clusterApiUrl(NETWORK as 'devnet' | 'mainnet-beta');
}

// Singleton connection
let connection: Connection | null = null;

export function getConnection(): Connection {
  if (!connection) {
    connection = new Connection(getRpcUrl(), {
      commitment: 'confirmed',
      confirmTransactionInitialTimeout: 60000,
    });
  }
  return connection;
}

export function getExplorerUrl(signature: string): string {
  const cluster = NETWORK === 'mainnet-beta' ? '' : `?cluster=${NETWORK}`;
  return `https://explorer.solana.com/tx/${signature}${cluster}`;
}

export function getAddressExplorerUrl(address: string): string {
  const cluster = NETWORK === 'mainnet-beta' ? '' : `?cluster=${NETWORK}`;
  return `https://explorer.solana.com/address/${address}${cluster}`;
}
```

**New Code:**
```typescript
import { Connection, clusterApiUrl } from '@solana/web3.js';

const HELIUS_API_KEY = import.meta.env.VITE_HELIUS_API_KEY || '';
const NETWORK = import.meta.env.VITE_SOLANA_NETWORK || 'devnet';

// RPC endpoints in priority order
const RPC_ENDPOINTS = {
  mainnet: [
    HELIUS_API_KEY ? `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}` : null,
    'https://api.mainnet-beta.solana.com',
    'https://solana-api.projectserum.com',
  ].filter(Boolean) as string[],
  devnet: [
    HELIUS_API_KEY ? `https://devnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}` : null,
    'https://api.devnet.solana.com',
  ].filter(Boolean) as string[],
};

let currentRpcIndex = 0;
let connection: Connection | null = null;

function getRpcUrl(): string {
  const endpoints = NETWORK === 'mainnet-beta' ? RPC_ENDPOINTS.mainnet : RPC_ENDPOINTS.devnet;
  return endpoints[currentRpcIndex] || clusterApiUrl(NETWORK as 'devnet' | 'mainnet-beta');
}

export function getConnection(): Connection {
  if (!connection) {
    connection = new Connection(getRpcUrl(), {
      commitment: 'confirmed',
      confirmTransactionInitialTimeout: 60000,
    });
  }
  return connection;
}

/**
 * Switch to next available RPC endpoint (for fallback on failures)
 */
export function switchToNextRpc(): boolean {
  const endpoints = NETWORK === 'mainnet-beta' ? RPC_ENDPOINTS.mainnet : RPC_ENDPOINTS.devnet;

  if (currentRpcIndex < endpoints.length - 1) {
    currentRpcIndex++;
    connection = null; // Force new connection
    console.warn(`Switching to fallback RPC: ${getRpcUrl()}`);
    return true;
  }

  return false;
}

/**
 * Reset to primary RPC endpoint
 */
export function resetToPrimaryRpc(): void {
  currentRpcIndex = 0;
  connection = null;
}

/**
 * Get current RPC endpoint URL (for debugging)
 */
export function getCurrentRpcUrl(): string {
  return getRpcUrl();
}

/**
 * Check if Helius API key is configured
 */
export function hasHeliusApiKey(): boolean {
  return !!HELIUS_API_KEY;
}

/**
 * Get the Helius API key (for direct API calls)
 */
export function getHeliusApiKey(): string {
  return HELIUS_API_KEY;
}

/**
 * Get current network
 */
export function getNetwork(): string {
  return NETWORK;
}

export function getExplorerUrl(signature: string): string {
  const cluster = NETWORK === 'mainnet-beta' ? '' : `?cluster=${NETWORK}`;
  return `https://explorer.solana.com/tx/${signature}${cluster}`;
}

export function getAddressExplorerUrl(address: string): string {
  const cluster = NETWORK === 'mainnet-beta' ? '' : `?cluster=${NETWORK}`;
  return `https://explorer.solana.com/address/${address}${cluster}`;
}
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/lib/solana/connection.ts
```
**Expected Output:**
```
(no output - successful compilation)
```

---

### Task 4: Write Test for Transaction Service

**File:** `/Users/lucasbertol/zenwallet/tests/solana/transactionService.test.ts`
**Action:** Create

**New Code:**
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { Keypair, VersionedTransaction } from '@solana/web3.js';

// Mock the connection module
vi.mock('@/lib/solana/connection', () => ({
  getConnection: vi.fn(() => ({
    sendRawTransaction: vi.fn().mockResolvedValue('mock-signature'),
    getLatestBlockhash: vi.fn().mockResolvedValue({
      blockhash: 'mock-blockhash',
      lastValidBlockHeight: 1000,
    }),
    confirmTransaction: vi.fn().mockResolvedValue({ value: { err: null } }),
  })),
}));

describe('TransactionService', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('signWithKeypair', () => {
    it('should sign transaction with keypair', async () => {
      // Import after mocking
      const { signWithKeypair } = await import('@/lib/solana/transactionService');

      const keypair = Keypair.generate();

      // Create a minimal mock VersionedTransaction
      const mockTx = {
        sign: vi.fn(),
        serialize: vi.fn().mockReturnValue(new Uint8Array([1, 2, 3])),
      } as unknown as VersionedTransaction;

      await signWithKeypair(mockTx, keypair);

      expect(mockTx.sign).toHaveBeenCalledWith([keypair]);
    });
  });

  describe('signWithWalletAdapter', () => {
    it('should throw error if wallet does not support signing', async () => {
      const { signWithWalletAdapter } = await import('@/lib/solana/transactionService');

      const mockWallet = {
        signTransaction: null,
      };

      const mockTx = {} as VersionedTransaction;

      await expect(
        signWithWalletAdapter(mockTx, mockWallet as any)
      ).rejects.toThrow('Wallet does not support transaction signing');
    });

    it('should call wallet adapter signTransaction', async () => {
      const { signWithWalletAdapter } = await import('@/lib/solana/transactionService');

      const signedTx = { signed: true } as unknown as VersionedTransaction;
      const mockWallet = {
        signTransaction: vi.fn().mockResolvedValue(signedTx),
      };

      const mockTx = {} as VersionedTransaction;

      const result = await signWithWalletAdapter(mockTx, mockWallet as any);

      expect(mockWallet.signTransaction).toHaveBeenCalledWith(mockTx);
      expect(result).toBe(signedTx);
    });
  });

  describe('signTransaction', () => {
    it('should use keypair for internal wallet type', async () => {
      const { signTransaction } = await import('@/lib/solana/transactionService');

      const keypair = Keypair.generate();
      const mockTx = {
        sign: vi.fn(),
      } as unknown as VersionedTransaction;

      await signTransaction(mockTx, 'internal', keypair, null);

      expect(mockTx.sign).toHaveBeenCalledWith([keypair]);
    });

    it('should throw error for internal wallet without keypair', async () => {
      const { signTransaction } = await import('@/lib/solana/transactionService');

      const mockTx = {} as VersionedTransaction;

      await expect(
        signTransaction(mockTx, 'internal', null, null)
      ).rejects.toThrow('Internal wallet requires keypair for signing');
    });

    it('should throw error for external wallet without adapter', async () => {
      const { signTransaction } = await import('@/lib/solana/transactionService');

      const mockTx = {} as VersionedTransaction;

      await expect(
        signTransaction(mockTx, 'external', null, null)
      ).rejects.toThrow('External wallet requires wallet adapter for signing');
    });
  });
});
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npm test -- tests/solana/transactionService.test.ts --run
```
**Expected Output:**
```
 PASS  tests/solana/transactionService.test.ts
  TransactionService
    signWithKeypair
      ✓ should sign transaction with keypair
    signWithWalletAdapter
      ✓ should throw error if wallet does not support signing
      ✓ should call wallet adapter signTransaction
    signTransaction
      ✓ should use keypair for internal wallet type
      ✓ should throw error for internal wallet without keypair
      ✓ should throw error for external wallet without adapter

Test Files  1 passed (1)
Tests       6 passed (6)
```

---

### Task 5: Run Tests and Commit Batch 1

**Step 1: Run all tests**
```bash
cd /Users/lucasbertol/zenwallet && npm test -- --run
```
**Expected Output:**
```
 PASS  tests/solana/transactionService.test.ts
 PASS  tests/security/rateLimiter.test.ts
 PASS  tests/gamification/xp.test.ts

Test Files  3 passed (3)
```

**Step 2: Commit changes**
```bash
cd /Users/lucasbertol/zenwallet && git add src/types/transaction.ts src/lib/solana/transactionService.ts src/lib/solana/connection.ts tests/solana/transactionService.test.ts && git commit -m "feat: add unified transaction signing service with RPC fallback

- Create TransactionService for unified signing (internal/external wallets)
- Add retry logic with exponential backoff for API calls
- Implement RPC fallback chain for resilience
- Add transaction type definitions
- Include unit tests for transaction service"
```

---

### CODE REVIEW CHECKPOINT - Batch 1

**Before proceeding to Batch 2, run code review:**

1. **Dispatch all 3 reviewers in parallel:**
   - REQUIRED SUB-SKILL: Use requesting-code-review
   - All reviewers run simultaneously (code-reviewer, business-logic-reviewer, security-reviewer)
   - Wait for all to complete

2. **Handle findings by severity (MANDATORY):**

**Critical/High/Medium Issues:**
- Fix immediately (do NOT add TODO comments for these severities)
- Re-run all 3 reviewers in parallel after fixes
- Repeat until zero Critical/High/Medium issues remain

**Low Issues:**
- Add `TODO(review):` comments in code at the relevant location
- Format: `TODO(review): [Issue description] (reported by [reviewer] on [date], severity: Low)`

**Cosmetic/Nitpick Issues:**
- Add `FIXME(nitpick):` comments in code at the relevant location

3. **Proceed only when:**
   - Zero Critical/High/Medium issues remain
   - All Low issues have TODO(review): comments added
   - All Cosmetic issues have FIXME(nitpick): comments added

---

## Batch 2: Fix Swap for External Wallets (Tasks 6-10)

This batch updates the swap functionality to work with both internal and external wallets.

### Task 6: Update Jupiter Client to Return Unsigned Transaction

**File:** `/Users/lucasbertol/zenwallet/src/lib/jupiter/client.ts`
**Action:** Modify (full file replacement)

**Current Code:**
```typescript
import { VersionedTransaction, Keypair } from '@solana/web3.js';
import { getConnection } from '@/lib/solana/connection';
import { ZENWALLET_FEE_BPS } from '@/constants/tokens';

const JUPITER_API_URL = 'https://quote-api.jup.ag/v6';

export interface JupiterQuote {
  inputMint: string;
  inAmount: string;
  outputMint: string;
  outAmount: string;
  priceImpactPct: string;
  routePlan: Array<{
    swapInfo: {
      ammKey: string;
      label: string;
      inputMint: string;
      outputMint: string;
      inAmount: string;
      outAmount: string;
      feeAmount: string;
      feeMint: string;
    };
    percent: number;
  }>;
}

export interface SwapResult {
  signature: string;
  status: 'success' | 'failed';
  error?: string;
}

export async function getQuote(
  inputMint: string,
  outputMint: string,
  amount: number, // In smallest unit (lamports for SOL)
  slippageBps: number = 50 // 0.5% default slippage
): Promise<JupiterQuote | null> {
  try {
    const params = new URLSearchParams({
      inputMint,
      outputMint,
      amount: amount.toString(),
      slippageBps: slippageBps.toString(),
      platformFeeBps: ZENWALLET_FEE_BPS.toString(),
    });

    const response = await fetch(`${JUPITER_API_URL}/quote?${params}`);

    if (!response.ok) {
      throw new Error(`Quote failed: ${response.statusText}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error getting quote:', error);
    return null;
  }
}

export async function executeSwap(
  quote: JupiterQuote,
  userPublicKey: string,
  keypair: Keypair
): Promise<SwapResult> {
  const connection = getConnection();

  try {
    // Get swap transaction
    const swapResponse = await fetch(`${JUPITER_API_URL}/swap`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        quoteResponse: quote,
        userPublicKey,
        wrapAndUnwrapSol: true,
        dynamicComputeUnitLimit: true,
        prioritizationFeeLamports: 'auto',
      }),
    });

    if (!swapResponse.ok) {
      throw new Error(`Swap request failed: ${swapResponse.statusText}`);
    }

    const swapData = await swapResponse.json();
    const swapTransactionBuf = Buffer.from(swapData.swapTransaction, 'base64');
    const transaction = VersionedTransaction.deserialize(swapTransactionBuf);

    // Sign transaction
    transaction.sign([keypair]);

    // Send transaction
    const rawTransaction = transaction.serialize();
    const signature = await connection.sendRawTransaction(rawTransaction, {
      skipPreflight: true,
      maxRetries: 3,
    });

    // Confirm transaction
    const latestBlockHash = await connection.getLatestBlockhash();
    await connection.confirmTransaction({
      blockhash: latestBlockHash.blockhash,
      lastValidBlockHeight: latestBlockHash.lastValidBlockHeight,
      signature,
    });

    return { signature, status: 'success' };
  } catch (error) {
    console.error('Error executing swap:', error);
    return {
      signature: '',
      status: 'failed',
      error: (error as Error).message,
    };
  }
}

export function calculateOutputAmount(
  quote: JupiterQuote,
  outputDecimals: number
): number {
  const outAmount = parseInt(quote.outAmount);
  return outAmount / Math.pow(10, outputDecimals);
}

export function calculatePriceImpact(quote: JupiterQuote): number {
  return parseFloat(quote.priceImpactPct) * 100;
}
```

**New Code:**
```typescript
import { VersionedTransaction } from '@solana/web3.js';
import { ZENWALLET_FEE_BPS } from '@/constants/tokens';

const JUPITER_API_URL = 'https://quote-api.jup.ag/v6';

// Retry configuration
const MAX_RETRIES = 3;
const RETRY_DELAY_MS = 1000;

export interface JupiterQuote {
  inputMint: string;
  inAmount: string;
  outputMint: string;
  outAmount: string;
  priceImpactPct: string;
  routePlan: Array<{
    swapInfo: {
      ammKey: string;
      label: string;
      inputMint: string;
      outputMint: string;
      inAmount: string;
      outAmount: string;
      feeAmount: string;
      feeMint: string;
    };
    percent: number;
  }>;
}

export interface SwapResult {
  signature: string;
  status: 'success' | 'failed';
  error?: string;
}

export interface SwapTransaction {
  transaction: VersionedTransaction;
  quote: JupiterQuote;
}

/**
 * Sleep utility for retry delays
 */
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Retry wrapper for fetch operations with rate limit handling
 */
async function fetchWithRetry(
  url: string,
  options?: RequestInit,
  maxRetries: number = MAX_RETRIES
): Promise<Response> {
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);

      // Handle rate limiting
      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After');
        const delay = retryAfter ? parseInt(retryAfter) * 1000 : RETRY_DELAY_MS * attempt * 2;
        console.warn(`Rate limited. Retrying after ${delay}ms...`);
        await sleep(delay);
        continue;
      }

      return response;
    } catch (error) {
      lastError = error as Error;
      if (attempt < maxRetries) {
        const delay = RETRY_DELAY_MS * attempt;
        console.warn(`Fetch attempt ${attempt} failed. Retrying in ${delay}ms...`);
        await sleep(delay);
      }
    }
  }

  throw lastError || new Error('Fetch failed after retries');
}

/**
 * Get a swap quote from Jupiter
 */
export async function getQuote(
  inputMint: string,
  outputMint: string,
  amount: number,
  slippageBps: number = 50
): Promise<JupiterQuote | null> {
  try {
    const params = new URLSearchParams({
      inputMint,
      outputMint,
      amount: amount.toString(),
      slippageBps: slippageBps.toString(),
      platformFeeBps: ZENWALLET_FEE_BPS.toString(),
    });

    const response = await fetchWithRetry(`${JUPITER_API_URL}/quote?${params}`);

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`Quote failed: ${response.status} - ${errorText}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error getting quote:', error);
    return null;
  }
}

/**
 * Get unsigned swap transaction from Jupiter
 * This returns the transaction WITHOUT signing - signing is handled by transactionService
 */
export async function getSwapTransaction(
  quote: JupiterQuote,
  userPublicKey: string
): Promise<SwapTransaction> {
  const response = await fetchWithRetry(`${JUPITER_API_URL}/swap`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      quoteResponse: quote,
      userPublicKey,
      wrapAndUnwrapSol: true,
      dynamicComputeUnitLimit: true,
      prioritizationFeeLamports: 'auto',
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Swap request failed: ${response.status} - ${errorText}`);
  }

  const swapData = await response.json();

  if (swapData.error) {
    throw new Error(swapData.error);
  }

  const swapTransactionBuf = Buffer.from(swapData.swapTransaction, 'base64');
  const transaction = VersionedTransaction.deserialize(swapTransactionBuf);

  return { transaction, quote };
}

export function calculateOutputAmount(
  quote: JupiterQuote,
  outputDecimals: number
): number {
  const outAmount = parseInt(quote.outAmount);
  return outAmount / Math.pow(10, outputDecimals);
}

export function calculatePriceImpact(quote: JupiterQuote): number {
  return parseFloat(quote.priceImpactPct) * 100;
}
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/lib/jupiter/client.ts
```
**Expected Output:**
```
(no output - successful compilation)
```

---

### Task 7: Update useSwap Hook for Unified Signing

**File:** `/Users/lucasbertol/zenwallet/src/hooks/useSwap.ts`
**Action:** Modify (full file replacement)

**New Code:**
```typescript
import { useState, useCallback } from 'react';
import { useWallet } from '@solana/wallet-adapter-react';
import { useWalletStore } from '@/stores/walletStore';
import { useGamificationStore } from '@/stores/gamificationStore';
import {
  getQuote,
  getSwapTransaction,
  JupiterQuote,
  SwapResult,
} from '@/lib/jupiter/client';
import { executeTransaction } from '@/lib/solana/transactionService';
import { TokenBalance } from '@/types/token';
import { toast } from '@/stores/toastStore';

interface UseSwapReturn {
  quote: JupiterQuote | null;
  isLoadingQuote: boolean;
  isSwapping: boolean;
  error: string | null;
  fetchQuote: (
    inputToken: TokenBalance,
    outputMint: string,
    amount: number
  ) => Promise<void>;
  swap: () => Promise<SwapResult>;
  clearQuote: () => void;
}

export function useSwap(): UseSwapReturn {
  const { getKeypair, publicKey, walletType } = useWalletStore();
  const walletAdapter = useWallet();
  const { addXP, incrementStat } = useGamificationStore();

  const [quote, setQuote] = useState<JupiterQuote | null>(null);
  const [isLoadingQuote, setIsLoadingQuote] = useState(false);
  const [isSwapping, setIsSwapping] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetchQuote = useCallback(
    async (inputToken: TokenBalance, outputMint: string, amount: number) => {
      if (amount <= 0) {
        setQuote(null);
        return;
      }

      setIsLoadingQuote(true);
      setError(null);

      try {
        const inputAmount = Math.floor(amount * Math.pow(10, inputToken.decimals));

        const fetchedQuote = await getQuote(
          inputToken.mint,
          outputMint,
          inputAmount
        );

        if (!fetchedQuote) {
          setError('Unable to get quote. Try a different amount or pair.');
          setQuote(null);
        } else {
          setQuote(fetchedQuote);
        }
      } catch (err) {
        setError((err as Error).message);
        setQuote(null);
      } finally {
        setIsLoadingQuote(false);
      }
    },
    []
  );

  const swap = useCallback(async (): Promise<SwapResult> => {
    if (!quote || !publicKey) {
      return { signature: '', status: 'failed', error: 'Missing quote or wallet' };
    }

    // Validate wallet type and signing capability
    if (walletType === 'internal') {
      const keypair = getKeypair();
      if (!keypair) {
        return { signature: '', status: 'failed', error: 'Wallet not unlocked. Please unlock your wallet.' };
      }
    } else if (walletType === 'external') {
      if (!walletAdapter.connected || !walletAdapter.signTransaction) {
        return { signature: '', status: 'failed', error: 'External wallet not connected or does not support signing.' };
      }
    } else {
      return { signature: '', status: 'failed', error: 'Unknown wallet type' };
    }

    setIsSwapping(true);
    setError(null);

    try {
      // Get unsigned transaction from Jupiter
      const { transaction } = await getSwapTransaction(quote, publicKey);

      // Execute transaction using unified signing
      const result = await executeTransaction(
        transaction,
        walletType!,
        walletType === 'internal' ? getKeypair() : null,
        walletType === 'external' ? walletAdapter : null
      );

      if (result.status === 'success') {
        addXP('swap');
        incrementStat('totalSwaps');
        setQuote(null);
        toast.success('Swap completed successfully!');
      } else {
        setError(result.error || 'Swap failed');
        toast.error(result.error || 'Swap failed');
      }

      return result;
    } catch (err) {
      const errorMessage = (err as Error).message;
      setError(errorMessage);
      toast.error(errorMessage);
      return { signature: '', status: 'failed', error: errorMessage };
    } finally {
      setIsSwapping(false);
    }
  }, [quote, publicKey, walletType, getKeypair, walletAdapter, addXP, incrementStat]);

  const clearQuote = useCallback(() => {
    setQuote(null);
    setError(null);
  }, []);

  return {
    quote,
    isLoadingQuote,
    isSwapping,
    error,
    fetchQuote,
    swap,
    clearQuote,
  };
}
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/hooks/useSwap.ts
```
**Expected Output:**
```
(no output - successful compilation)
```

---

### Task 8: Update useTransaction Hook for Unified Signing

**File:** `/Users/lucasbertol/zenwallet/src/hooks/useTransaction.ts`
**Action:** Modify (full file replacement)

**New Code:**
```typescript
import { useState, useCallback } from 'react';
import {
  PublicKey,
  Transaction,
  SystemProgram,
  LAMPORTS_PER_SOL,
  VersionedTransaction,
  TransactionMessage,
} from '@solana/web3.js';
import {
  getAssociatedTokenAddress,
  createTransferInstruction,
  createAssociatedTokenAccountInstruction,
  getAccount,
  TokenAccountNotFoundError,
} from '@solana/spl-token';
import { useWallet } from '@solana/wallet-adapter-react';
import { useWalletStore } from '@/stores/walletStore';
import { useGamificationStore } from '@/stores/gamificationStore';
import { getConnection } from '@/lib/solana/connection';
import { executeTransaction } from '@/lib/solana/transactionService';
import { validateSolanaAddress } from '@/lib/solana/transactions';
import { TransactionResult, TokenBalance } from '@/types/token';
import { SOL_MINT } from '@/constants/tokens';
import { toast } from '@/stores/toastStore';

interface UseTransactionReturn {
  send: (
    toAddress: string,
    amount: number,
    token: TokenBalance
  ) => Promise<TransactionResult>;
  isLoading: boolean;
  error: string | null;
  validateAddress: (address: string) => boolean;
}

export function useTransaction(): UseTransactionReturn {
  const { getKeypair, publicKey, walletType } = useWalletStore();
  const walletAdapter = useWallet();
  const { addXP, incrementStat } = useGamificationStore();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const send = useCallback(
    async (
      toAddress: string,
      amount: number,
      token: TokenBalance
    ): Promise<TransactionResult> => {
      setIsLoading(true);
      setError(null);

      // Validation
      if (!validateSolanaAddress(toAddress)) {
        setError('Invalid recipient address');
        setIsLoading(false);
        return { signature: '', status: 'failed', error: 'Invalid address' };
      }

      if (toAddress === publicKey) {
        setError('Cannot send to yourself');
        setIsLoading(false);
        return { signature: '', status: 'failed', error: 'Cannot send to yourself' };
      }

      if (amount <= 0) {
        setError('Amount must be greater than 0');
        setIsLoading(false);
        return { signature: '', status: 'failed', error: 'Invalid amount' };
      }

      if (amount > token.uiBalance) {
        setError('Insufficient balance');
        setIsLoading(false);
        return { signature: '', status: 'failed', error: 'Insufficient balance' };
      }

      // Validate wallet type and signing capability
      if (walletType === 'internal') {
        const keypair = getKeypair();
        if (!keypair) {
          setError('Wallet not unlocked');
          setIsLoading(false);
          return { signature: '', status: 'failed', error: 'Wallet not unlocked. Please unlock your wallet.' };
        }
      } else if (walletType === 'external') {
        if (!walletAdapter.connected || !walletAdapter.signTransaction) {
          setError('External wallet not connected');
          setIsLoading(false);
          return { signature: '', status: 'failed', error: 'External wallet not connected or does not support signing.' };
        }
      } else {
        setError('Unknown wallet type');
        setIsLoading(false);
        return { signature: '', status: 'failed', error: 'Unknown wallet type' };
      }

      try {
        const connection = getConnection();
        const fromPubkey = new PublicKey(publicKey!);
        const toPubkey = new PublicKey(toAddress);

        let transaction: Transaction;

        if (token.mint === SOL_MINT || token.isNative) {
          // SOL transfer
          const lamports = Math.floor(amount * LAMPORTS_PER_SOL);
          transaction = new Transaction().add(
            SystemProgram.transfer({
              fromPubkey,
              toPubkey,
              lamports,
            })
          );
        } else {
          // SPL token transfer
          const mintPubkey = new PublicKey(token.mint);
          const sourceATA = await getAssociatedTokenAddress(mintPubkey, fromPubkey);
          const destATA = await getAssociatedTokenAddress(mintPubkey, toPubkey);

          transaction = new Transaction();

          // Check if destination ATA exists
          try {
            await getAccount(connection, destATA);
          } catch (err) {
            if (err instanceof TokenAccountNotFoundError) {
              transaction.add(
                createAssociatedTokenAccountInstruction(
                  fromPubkey,
                  destATA,
                  toPubkey,
                  mintPubkey
                )
              );
            } else {
              throw err;
            }
          }

          const tokenAmount = BigInt(Math.floor(amount * Math.pow(10, token.decimals)));
          transaction.add(
            createTransferInstruction(sourceATA, destATA, fromPubkey, tokenAmount)
          );
        }

        // Get recent blockhash
        const { blockhash, lastValidBlockHeight } = await connection.getLatestBlockhash();
        transaction.recentBlockhash = blockhash;
        transaction.feePayer = fromPubkey;

        // Convert to VersionedTransaction for unified signing
        const messageV0 = new TransactionMessage({
          payerKey: fromPubkey,
          recentBlockhash: blockhash,
          instructions: transaction.instructions,
        }).compileToV0Message();

        const versionedTx = new VersionedTransaction(messageV0);

        // Execute transaction using unified signing
        const result = await executeTransaction(
          versionedTx,
          walletType!,
          walletType === 'internal' ? getKeypair() : null,
          walletType === 'external' ? walletAdapter : null
        );

        if (result.status === 'success') {
          addXP('send');
          incrementStat('totalTransactions');
          toast.success(`Sent ${amount} ${token.symbol} successfully!`);
        } else {
          setError(result.error || 'Transaction failed');
          toast.error(result.error || 'Transaction failed');
        }

        setIsLoading(false);
        return result;
      } catch (err) {
        const errorMessage = (err as Error).message;
        setError(errorMessage);
        setIsLoading(false);
        toast.error(errorMessage);
        return { signature: '', status: 'failed', error: errorMessage };
      }
    },
    [getKeypair, publicKey, walletType, walletAdapter, addXP, incrementStat]
  );

  return {
    send,
    isLoading,
    error,
    validateAddress: validateSolanaAddress,
  };
}
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/hooks/useTransaction.ts
```
**Expected Output:**
```
(no output - successful compilation)
```

---

### Task 9: Write Test for useSwap Hook

**File:** `/Users/lucasbertol/zenwallet/tests/hooks/useSwap.test.ts`
**Action:** Create

**New Code:**
```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { renderHook, act, waitFor } from '@testing-library/react';
import { useSwap } from '@/hooks/useSwap';
import { TokenBalance } from '@/types/token';

// Mock stores
vi.mock('@/stores/walletStore', () => ({
  useWalletStore: vi.fn(() => ({
    publicKey: 'mock-public-key',
    walletType: 'internal',
    getKeypair: vi.fn(() => ({
      publicKey: { toBase58: () => 'mock-public-key' },
      secretKey: new Uint8Array(64),
    })),
  })),
}));

vi.mock('@/stores/gamificationStore', () => ({
  useGamificationStore: vi.fn(() => ({
    addXP: vi.fn(),
    incrementStat: vi.fn(),
  })),
}));

vi.mock('@/stores/toastStore', () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
  },
}));

// Mock wallet adapter
vi.mock('@solana/wallet-adapter-react', () => ({
  useWallet: vi.fn(() => ({
    connected: true,
    signTransaction: vi.fn(),
  })),
}));

// Mock Jupiter client
vi.mock('@/lib/jupiter/client', () => ({
  getQuote: vi.fn(),
  getSwapTransaction: vi.fn(),
}));

// Mock transaction service
vi.mock('@/lib/solana/transactionService', () => ({
  executeTransaction: vi.fn(),
}));

describe('useSwap', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should initialize with default state', () => {
    const { result } = renderHook(() => useSwap());

    expect(result.current.quote).toBeNull();
    expect(result.current.isLoadingQuote).toBe(false);
    expect(result.current.isSwapping).toBe(false);
    expect(result.current.error).toBeNull();
  });

  it('should fetch quote successfully', async () => {
    const mockQuote = {
      inputMint: 'SOL',
      outputMint: 'USDC',
      inAmount: '1000000000',
      outAmount: '100000000',
      priceImpactPct: '0.01',
      routePlan: [],
    };

    const { getQuote } = await import('@/lib/jupiter/client');
    (getQuote as ReturnType<typeof vi.fn>).mockResolvedValue(mockQuote);

    const { result } = renderHook(() => useSwap());

    const mockToken: TokenBalance = {
      mint: 'So11111111111111111111111111111111111111112',
      symbol: 'SOL',
      name: 'Solana',
      decimals: 9,
      balance: 1000000000,
      uiBalance: 1,
      usdValue: 100,
    };

    await act(async () => {
      await result.current.fetchQuote(mockToken, 'USDC-mint', 1);
    });

    await waitFor(() => {
      expect(result.current.quote).toEqual(mockQuote);
      expect(result.current.error).toBeNull();
    });
  });

  it('should handle quote error', async () => {
    const { getQuote } = await import('@/lib/jupiter/client');
    (getQuote as ReturnType<typeof vi.fn>).mockResolvedValue(null);

    const { result } = renderHook(() => useSwap());

    const mockToken: TokenBalance = {
      mint: 'So11111111111111111111111111111111111111112',
      symbol: 'SOL',
      name: 'Solana',
      decimals: 9,
      balance: 1000000000,
      uiBalance: 1,
      usdValue: 100,
    };

    await act(async () => {
      await result.current.fetchQuote(mockToken, 'USDC-mint', 1);
    });

    await waitFor(() => {
      expect(result.current.quote).toBeNull();
      expect(result.current.error).toBe('Unable to get quote. Try a different amount or pair.');
    });
  });

  it('should clear quote', () => {
    const { result } = renderHook(() => useSwap());

    act(() => {
      result.current.clearQuote();
    });

    expect(result.current.quote).toBeNull();
    expect(result.current.error).toBeNull();
  });

  it('should not fetch quote for zero amount', async () => {
    const { getQuote } = await import('@/lib/jupiter/client');

    const { result } = renderHook(() => useSwap());

    const mockToken: TokenBalance = {
      mint: 'So11111111111111111111111111111111111111112',
      symbol: 'SOL',
      name: 'Solana',
      decimals: 9,
      balance: 1000000000,
      uiBalance: 1,
      usdValue: 100,
    };

    await act(async () => {
      await result.current.fetchQuote(mockToken, 'USDC-mint', 0);
    });

    expect(getQuote).not.toHaveBeenCalled();
    expect(result.current.quote).toBeNull();
  });
});
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npm test -- tests/hooks/useSwap.test.ts --run
```
**Expected Output:**
```
 PASS  tests/hooks/useSwap.test.ts
  useSwap
    ✓ should initialize with default state
    ✓ should fetch quote successfully
    ✓ should handle quote error
    ✓ should clear quote
    ✓ should not fetch quote for zero amount

Test Files  1 passed (1)
Tests       5 passed (5)
```

---

### Task 10: Run Tests and Commit Batch 2

**Step 1: Run all tests**
```bash
cd /Users/lucasbertol/zenwallet && npm test -- --run
```
**Expected Output:**
```
 PASS  tests/hooks/useSwap.test.ts
 PASS  tests/solana/transactionService.test.ts
 PASS  tests/security/rateLimiter.test.ts
 PASS  tests/gamification/xp.test.ts

Test Files  4 passed (4)
```

**Step 2: Commit changes**
```bash
cd /Users/lucasbertol/zenwallet && git add src/lib/jupiter/client.ts src/hooks/useSwap.ts src/hooks/useTransaction.ts tests/hooks/useSwap.test.ts && git commit -m "feat: fix swap and send for external wallets (Phantom/Solflare)

- Update Jupiter client to return unsigned transactions
- Modify useSwap to use unified transaction signing
- Update useTransaction for both internal and external wallets
- Add retry logic with rate limit handling to Jupiter API calls
- Include tests for useSwap hook"
```

---

### CODE REVIEW CHECKPOINT - Batch 2

**Before proceeding to Batch 3, run code review as described in Batch 1 checkpoint.**

---

## Batch 3: Transaction History Implementation (Tasks 11-16)

This batch implements transaction history using Helius API with fallback to Solana RPC.

### Task 11: Create Helius Service for Transaction History

**File:** `/Users/lucasbertol/zenwallet/src/lib/helius/historyService.ts`
**Action:** Create

**New Code:**
```typescript
import { getConnection, getHeliusApiKey, getNetwork, hasHeliusApiKey } from '@/lib/solana/connection';
import { TransactionHistoryItem, TransactionHistoryResponse } from '@/types/transaction';
import { PublicKey, ParsedTransactionWithMeta, LAMPORTS_PER_SOL } from '@solana/web3.js';
import { SOL_MINT, getTokenMetadata } from '@/constants/tokens';

const HELIUS_API_BASE = 'https://api.helius.xyz/v0';

// Retry configuration
const MAX_RETRIES = 3;
const RETRY_DELAY_MS = 1000;

interface HeliusTransaction {
  signature: string;
  timestamp: number;
  type: string;
  source: string;
  fee: number;
  feePayer: string;
  nativeTransfers?: Array<{
    fromUserAccount: string;
    toUserAccount: string;
    amount: number;
  }>;
  tokenTransfers?: Array<{
    fromUserAccount: string;
    toUserAccount: string;
    mint: string;
    tokenAmount: number;
    tokenStandard: string;
  }>;
  description?: string;
  events?: {
    swap?: {
      nativeInput?: { amount: number };
      nativeOutput?: { amount: number };
      tokenInputs?: Array<{ mint: string; tokenAmount: number }>;
      tokenOutputs?: Array<{ mint: string; tokenAmount: number }>;
    };
  };
}

/**
 * Sleep utility for retry delays
 */
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Fetch with retry and rate limit handling
 */
async function fetchWithRetry(url: string, options?: RequestInit): Promise<Response> {
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    try {
      const response = await fetch(url, options);

      if (response.status === 429) {
        const delay = RETRY_DELAY_MS * attempt * 2;
        console.warn(`Rate limited. Retrying after ${delay}ms...`);
        await sleep(delay);
        continue;
      }

      return response;
    } catch (error) {
      lastError = error as Error;
      if (attempt < MAX_RETRIES) {
        await sleep(RETRY_DELAY_MS * attempt);
      }
    }
  }

  throw lastError || new Error('Fetch failed after retries');
}

/**
 * Determine transaction type from Helius transaction data
 */
function determineTransactionType(
  tx: HeliusTransaction,
  userAddress: string
): 'send' | 'receive' | 'swap' | 'unknown' {
  // Check for swap
  if (tx.type === 'SWAP' || tx.events?.swap) {
    return 'swap';
  }

  // Check native transfers
  if (tx.nativeTransfers && tx.nativeTransfers.length > 0) {
    const transfer = tx.nativeTransfers[0];
    if (transfer.fromUserAccount === userAddress) {
      return 'send';
    }
    if (transfer.toUserAccount === userAddress) {
      return 'receive';
    }
  }

  // Check token transfers
  if (tx.tokenTransfers && tx.tokenTransfers.length > 0) {
    const transfer = tx.tokenTransfers[0];
    if (transfer.fromUserAccount === userAddress) {
      return 'send';
    }
    if (transfer.toUserAccount === userAddress) {
      return 'receive';
    }
  }

  return 'unknown';
}

/**
 * Parse Helius transaction to our format
 */
function parseHeliusTransaction(
  tx: HeliusTransaction,
  userAddress: string
): TransactionHistoryItem {
  const type = determineTransactionType(tx, userAddress);
  let amount: number | undefined;
  let symbol: string | undefined;
  let mint: string | undefined;
  let from: string | undefined;
  let to: string | undefined;

  // Extract transfer details
  if (tx.nativeTransfers && tx.nativeTransfers.length > 0) {
    const transfer = tx.nativeTransfers[0];
    amount = transfer.amount / LAMPORTS_PER_SOL;
    symbol = 'SOL';
    mint = SOL_MINT;
    from = transfer.fromUserAccount;
    to = transfer.toUserAccount;
  } else if (tx.tokenTransfers && tx.tokenTransfers.length > 0) {
    const transfer = tx.tokenTransfers[0];
    amount = transfer.tokenAmount;
    mint = transfer.mint;
    const tokenMeta = getTokenMetadata(mint);
    symbol = tokenMeta?.symbol || 'TOKEN';
    from = transfer.fromUserAccount;
    to = transfer.toUserAccount;
  }

  // For swaps, try to get better description
  if (type === 'swap' && tx.events?.swap) {
    const swap = tx.events.swap;
    if (swap.nativeInput && swap.tokenOutputs?.[0]) {
      const outputMeta = getTokenMetadata(swap.tokenOutputs[0].mint);
      symbol = `SOL -> ${outputMeta?.symbol || 'TOKEN'}`;
    } else if (swap.tokenInputs?.[0] && swap.nativeOutput) {
      const inputMeta = getTokenMetadata(swap.tokenInputs[0].mint);
      symbol = `${inputMeta?.symbol || 'TOKEN'} -> SOL`;
    }
  }

  return {
    signature: tx.signature,
    timestamp: tx.timestamp * 1000, // Convert to milliseconds
    type,
    status: 'success', // Helius only returns successful transactions
    amount,
    symbol,
    mint,
    from,
    to,
    fee: tx.fee / LAMPORTS_PER_SOL,
    description: tx.description,
  };
}

/**
 * Fetch transaction history using Helius API
 */
export async function fetchTransactionHistoryHelius(
  address: string,
  limit: number = 20,
  beforeSignature?: string
): Promise<TransactionHistoryResponse> {
  const apiKey = getHeliusApiKey();

  if (!apiKey) {
    throw new Error('Helius API key not configured');
  }

  const params: Record<string, string> = {
    'api-key': apiKey,
  };

  const url = `${HELIUS_API_BASE}/addresses/${address}/transactions?api-key=${apiKey}${
    beforeSignature ? `&before=${beforeSignature}` : ''
  }&limit=${limit}`;

  const response = await fetchWithRetry(url);

  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Helius API error: ${response.status} - ${errorText}`);
  }

  const transactions: HeliusTransaction[] = await response.json();

  const parsedTransactions = transactions.map((tx) =>
    parseHeliusTransaction(tx, address)
  );

  return {
    transactions: parsedTransactions,
    hasMore: transactions.length === limit,
    cursor: transactions.length > 0 ? transactions[transactions.length - 1].signature : undefined,
  };
}

/**
 * Parse RPC transaction to our format (fallback)
 */
function parseRpcTransaction(
  tx: ParsedTransactionWithMeta,
  signature: string,
  userAddress: string
): TransactionHistoryItem | null {
  if (!tx.meta || !tx.blockTime) {
    return null;
  }

  const preBalances = tx.meta.preBalances;
  const postBalances = tx.meta.postBalances;
  const accountKeys = tx.transaction.message.accountKeys;

  // Find user's account index
  const userIndex = accountKeys.findIndex(
    (key) => key.pubkey.toBase58() === userAddress
  );

  if (userIndex === -1) {
    return null;
  }

  const balanceChange = (postBalances[userIndex] - preBalances[userIndex]) / LAMPORTS_PER_SOL;
  const fee = tx.meta.fee / LAMPORTS_PER_SOL;

  let type: 'send' | 'receive' | 'swap' | 'unknown' = 'unknown';
  if (balanceChange < 0) {
    type = 'send';
  } else if (balanceChange > 0) {
    type = 'receive';
  }

  return {
    signature,
    timestamp: tx.blockTime * 1000,
    type,
    status: tx.meta.err ? 'failed' : 'success',
    amount: Math.abs(balanceChange),
    symbol: 'SOL',
    mint: SOL_MINT,
    fee,
  };
}

/**
 * Fetch transaction history using Solana RPC (fallback)
 */
export async function fetchTransactionHistoryRpc(
  address: string,
  limit: number = 20,
  beforeSignature?: string
): Promise<TransactionHistoryResponse> {
  const connection = getConnection();
  const pubkey = new PublicKey(address);

  const signatures = await connection.getSignaturesForAddress(pubkey, {
    limit,
    before: beforeSignature,
  });

  if (signatures.length === 0) {
    return { transactions: [], hasMore: false };
  }

  const transactions: TransactionHistoryItem[] = [];

  // Fetch transaction details in batches
  const batchSize = 10;
  for (let i = 0; i < signatures.length; i += batchSize) {
    const batch = signatures.slice(i, i + batchSize);
    const txs = await connection.getParsedTransactions(
      batch.map((s) => s.signature),
      { maxSupportedTransactionVersion: 0 }
    );

    for (let j = 0; j < txs.length; j++) {
      const tx = txs[j];
      if (tx) {
        const parsed = parseRpcTransaction(tx, batch[j].signature, address);
        if (parsed) {
          transactions.push(parsed);
        }
      }
    }
  }

  return {
    transactions,
    hasMore: signatures.length === limit,
    cursor: signatures.length > 0 ? signatures[signatures.length - 1].signature : undefined,
  };
}

/**
 * Fetch transaction history with automatic fallback
 */
export async function fetchTransactionHistory(
  address: string,
  limit: number = 20,
  beforeSignature?: string
): Promise<TransactionHistoryResponse> {
  // Try Helius first if available
  if (hasHeliusApiKey()) {
    try {
      return await fetchTransactionHistoryHelius(address, limit, beforeSignature);
    } catch (error) {
      console.warn('Helius API failed, falling back to RPC:', error);
    }
  }

  // Fallback to RPC
  return await fetchTransactionHistoryRpc(address, limit, beforeSignature);
}
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/lib/helius/historyService.ts
```
**Expected Output:**
```
(no output - successful compilation)
```

---

### Task 12: Create useTransactionHistory Hook

**File:** `/Users/lucasbertol/zenwallet/src/hooks/useTransactionHistory.ts`
**Action:** Create

**New Code:**
```typescript
import { useState, useEffect, useCallback } from 'react';
import { useWalletStore } from '@/stores/walletStore';
import { fetchTransactionHistory } from '@/lib/helius/historyService';
import { TransactionHistoryItem } from '@/types/transaction';

interface UseTransactionHistoryReturn {
  transactions: TransactionHistoryItem[];
  isLoading: boolean;
  isLoadingMore: boolean;
  error: string | null;
  hasMore: boolean;
  refresh: () => Promise<void>;
  loadMore: () => Promise<void>;
}

export function useTransactionHistory(
  limit: number = 20
): UseTransactionHistoryReturn {
  const { publicKey } = useWalletStore();
  const [transactions, setTransactions] = useState<TransactionHistoryItem[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isLoadingMore, setIsLoadingMore] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [hasMore, setHasMore] = useState(false);
  const [cursor, setCursor] = useState<string | undefined>(undefined);

  const refresh = useCallback(async () => {
    if (!publicKey) {
      setTransactions([]);
      setIsLoading(false);
      return;
    }

    setIsLoading(true);
    setError(null);

    try {
      const result = await fetchTransactionHistory(publicKey, limit);
      setTransactions(result.transactions);
      setHasMore(result.hasMore);
      setCursor(result.cursor);
    } catch (err) {
      setError((err as Error).message);
      setTransactions([]);
    } finally {
      setIsLoading(false);
    }
  }, [publicKey, limit]);

  const loadMore = useCallback(async () => {
    if (!publicKey || !hasMore || isLoadingMore || !cursor) {
      return;
    }

    setIsLoadingMore(true);

    try {
      const result = await fetchTransactionHistory(publicKey, limit, cursor);
      setTransactions((prev) => [...prev, ...result.transactions]);
      setHasMore(result.hasMore);
      setCursor(result.cursor);
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setIsLoadingMore(false);
    }
  }, [publicKey, hasMore, isLoadingMore, cursor, limit]);

  useEffect(() => {
    refresh();
  }, [refresh]);

  return {
    transactions,
    isLoading,
    isLoadingMore,
    error,
    hasMore,
    refresh,
    loadMore,
  };
}
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/hooks/useTransactionHistory.ts
```
**Expected Output:**
```
(no output - successful compilation)
```

---

### Task 13: Create Activity Page Component

**File:** `/Users/lucasbertol/zenwallet/src/pages/Activity.tsx`
**Action:** Create

**New Code:**
```typescript
import { motion } from 'framer-motion';
import { useTransactionHistory } from '@/hooks/useTransactionHistory';
import { TransactionHistoryItem } from '@/types/transaction';
import { getExplorerUrl } from '@/lib/solana/connection';
import { Skeleton } from '@/components/ui/Skeleton';
import { EmptyState } from '@/components/ui/EmptyState';

function formatTimestamp(timestamp: number): string {
  const date = new Date(timestamp);
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / (1000 * 60));
  const diffHours = Math.floor(diffMs / (1000 * 60 * 60));
  const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));

  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  if (diffDays < 7) return `${diffDays}d ago`;

  return date.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined,
  });
}

function getTransactionIcon(type: TransactionHistoryItem['type']): React.ReactNode {
  switch (type) {
    case 'send':
      return (
        <div className="w-10 h-10 rounded-full bg-error/20 flex items-center justify-center">
          <svg className="w-5 h-5 text-error" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 11l5-5m0 0l5 5m-5-5v12" />
          </svg>
        </div>
      );
    case 'receive':
      return (
        <div className="w-10 h-10 rounded-full bg-success/20 flex items-center justify-center">
          <svg className="w-5 h-5 text-success" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 13l-5 5m0 0l-5-5m5 5V6" />
          </svg>
        </div>
      );
    case 'swap':
      return (
        <div className="w-10 h-10 rounded-full bg-accent-purple/20 flex items-center justify-center">
          <svg className="w-5 h-5 text-accent-purple" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
          </svg>
        </div>
      );
    default:
      return (
        <div className="w-10 h-10 rounded-full bg-bg-tertiary flex items-center justify-center">
          <svg className="w-5 h-5 text-text-muted" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        </div>
      );
  }
}

function TransactionItem({ tx }: { tx: TransactionHistoryItem }) {
  const typeLabels: Record<TransactionHistoryItem['type'], string> = {
    send: 'Sent',
    receive: 'Received',
    swap: 'Swapped',
    unknown: 'Transaction',
  };

  return (
    <motion.a
      href={getExplorerUrl(tx.signature)}
      target="_blank"
      rel="noopener noreferrer"
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      className="flex items-center gap-4 p-4 bg-bg-secondary rounded-xl hover:bg-bg-tertiary transition-colors"
    >
      {getTransactionIcon(tx.type)}

      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2">
          <span className="font-semibold text-text-primary">
            {typeLabels[tx.type]}
          </span>
          {tx.status === 'failed' && (
            <span className="text-xs px-2 py-0.5 bg-error/20 text-error rounded-full">
              Failed
            </span>
          )}
        </div>
        <p className="text-sm text-text-muted truncate">
          {tx.description || tx.symbol || 'Unknown'}
        </p>
      </div>

      <div className="text-right">
        {tx.amount !== undefined && (
          <p
            className={`font-semibold ${
              tx.type === 'receive'
                ? 'text-success'
                : tx.type === 'send'
                ? 'text-error'
                : 'text-text-primary'
            }`}
          >
            {tx.type === 'receive' ? '+' : tx.type === 'send' ? '-' : ''}
            {tx.amount.toLocaleString(undefined, { maximumFractionDigits: 6 })}{' '}
            {tx.symbol}
          </p>
        )}
        <p className="text-xs text-text-muted">{formatTimestamp(tx.timestamp)}</p>
      </div>
    </motion.a>
  );
}

function TransactionSkeleton() {
  return (
    <div className="flex items-center gap-4 p-4 bg-bg-secondary rounded-xl">
      <Skeleton className="w-10 h-10 rounded-full" />
      <div className="flex-1">
        <Skeleton className="h-4 w-20 mb-2" />
        <Skeleton className="h-3 w-32" />
      </div>
      <div className="text-right">
        <Skeleton className="h-4 w-16 mb-2" />
        <Skeleton className="h-3 w-12" />
      </div>
    </div>
  );
}

export default function ActivityPage() {
  const {
    transactions,
    isLoading,
    isLoadingMore,
    error,
    hasMore,
    refresh,
    loadMore,
  } = useTransactionHistory();

  return (
    <div className="min-h-screen p-6 pb-24">
      {/* Header */}
      <motion.div
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        className="mb-6"
      >
        <div className="flex justify-between items-center">
          <h1 className="text-2xl font-bold text-text-primary">Activity</h1>
          <button
            onClick={refresh}
            disabled={isLoading}
            className="text-text-muted hover:text-text-primary transition-colors"
          >
            <svg
              className={`w-5 h-5 ${isLoading ? 'animate-spin' : ''}`}
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
              />
            </svg>
          </button>
        </div>
        <p className="text-text-muted text-sm mt-1">
          Your recent transactions
        </p>
      </motion.div>

      {/* Error State */}
      {error && (
        <motion.div
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          className="bg-error/10 border border-error/20 rounded-xl p-4 mb-6"
        >
          <p className="text-error text-sm">{error}</p>
          <button
            onClick={refresh}
            className="text-error underline text-sm mt-2"
          >
            Try again
          </button>
        </motion.div>
      )}

      {/* Loading State */}
      {isLoading && (
        <div className="space-y-3">
          {[...Array(5)].map((_, i) => (
            <TransactionSkeleton key={i} />
          ))}
        </div>
      )}

      {/* Empty State */}
      {!isLoading && transactions.length === 0 && !error && (
        <EmptyState
          icon={
            <svg className="w-12 h-12" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
            </svg>
          }
          title="No transactions yet"
          description="Your transaction history will appear here once you start sending, receiving, or swapping tokens."
        />
      )}

      {/* Transaction List */}
      {!isLoading && transactions.length > 0 && (
        <motion.div
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          className="space-y-3"
        >
          {transactions.map((tx) => (
            <TransactionItem key={tx.signature} tx={tx} />
          ))}

          {/* Load More Button */}
          {hasMore && (
            <button
              onClick={loadMore}
              disabled={isLoadingMore}
              className="w-full py-3 text-center text-solana-green hover:underline disabled:opacity-50"
            >
              {isLoadingMore ? 'Loading...' : 'Load more'}
            </button>
          )}
        </motion.div>
      )}
    </div>
  );
}
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/pages/Activity.tsx
```
**Expected Output:**
```
(no output - successful compilation)
```

---

### Task 14: Add Activity Route to App

**File:** `/Users/lucasbertol/zenwallet/src/App.tsx`
**Action:** Modify

**Current Code (lines 20-24):**
```typescript
// Main app pages - lazy loaded
const HomePage = lazy(() => import('./pages/Home'));
const AssetsPage = lazy(() => import('./pages/Assets'));
const SwapPage = lazy(() => import('./pages/Swap'));
const AchievementsPage = lazy(() => import('./pages/Achievements'));
const SettingsPage = lazy(() => import('./pages/Settings'));
```

**New Code:**
```typescript
// Main app pages - lazy loaded
const HomePage = lazy(() => import('./pages/Home'));
const AssetsPage = lazy(() => import('./pages/Assets'));
const SwapPage = lazy(() => import('./pages/Swap'));
const ActivityPage = lazy(() => import('./pages/Activity'));
const AchievementsPage = lazy(() => import('./pages/Achievements'));
const SettingsPage = lazy(() => import('./pages/Settings'));
```

**Also add after the swap route (after line 138 in original):**

**Current Code (around lines 133-140):**
```typescript
                <Route
                  path="/swap"
                  element={
                    <RequireWallet>
                      <SwapPage />
                    </RequireWallet>
                  }
                />
                <Route
                  path="/achievements"
```

**New Code:**
```typescript
                <Route
                  path="/swap"
                  element={
                    <RequireWallet>
                      <SwapPage />
                    </RequireWallet>
                  }
                />
                <Route
                  path="/activity"
                  element={
                    <RequireWallet>
                      <ActivityPage />
                    </RequireWallet>
                  }
                />
                <Route
                  path="/achievements"
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/App.tsx
```
**Expected Output:**
```
(no output - successful compilation)
```

---

### Task 15: Add Activity to Bottom Navigation

**File:** `/Users/lucasbertol/zenwallet/src/components/ui/BottomNav.tsx`
**Action:** Modify

**Current Code (lines 28-36):**
```typescript
  {
    path: '/swap',
    label: 'Swap',
    icon: (
      <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
      </svg>
    ),
  },
  {
    path: '/achievements',
```

**New Code:**
```typescript
  {
    path: '/swap',
    label: 'Swap',
    icon: (
      <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
      </svg>
    ),
  },
  {
    path: '/activity',
    label: 'Activity',
    icon: (
      <svg className="w-6 h-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
      </svg>
    ),
  },
  {
    path: '/achievements',
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/components/ui/BottomNav.tsx
```
**Expected Output:**
```
(no output - successful compilation)
```

---

### Task 16: Run Tests and Commit Batch 3

**Step 1: Run all tests**
```bash
cd /Users/lucasbertol/zenwallet && npm test -- --run
```
**Expected Output:**
```
 PASS  tests/hooks/useSwap.test.ts
 PASS  tests/solana/transactionService.test.ts
 PASS  tests/security/rateLimiter.test.ts
 PASS  tests/gamification/xp.test.ts

Test Files  4 passed (4)
```

**Step 2: Build to verify no type errors**
```bash
cd /Users/lucasbertol/zenwallet && npm run build
```
**Expected Output:**
```
vite v6.x.x building for production...
...
dist/index.html                  x.xx kB
...
Build completed successfully
```

**Step 3: Commit changes**
```bash
cd /Users/lucasbertol/zenwallet && git add src/lib/helius/historyService.ts src/hooks/useTransactionHistory.ts src/pages/Activity.tsx src/App.tsx src/components/ui/BottomNav.tsx && git commit -m "feat: implement transaction history with Helius API fallback

- Create Helius history service with RPC fallback
- Add useTransactionHistory hook with pagination
- Implement Activity page with transaction list
- Add Activity route and navigation tab
- Support send, receive, and swap transaction types"
```

---

### CODE REVIEW CHECKPOINT - Batch 3

**Before proceeding to Batch 4, run code review as described in Batch 1 checkpoint.**

---

## Batch 4: Token Balance Improvements (Tasks 17-19)

This batch improves token fetching with retry logic and better error handling.

### Task 17: Update Token Fetching with Retry Logic

**File:** `/Users/lucasbertol/zenwallet/src/lib/solana/tokens.ts`
**Action:** Modify (full file replacement)

**New Code:**
```typescript
import { PublicKey, LAMPORTS_PER_SOL } from '@solana/web3.js';
import { getConnection, getHeliusApiKey, hasHeliusApiKey, getNetwork } from './connection';
import { TokenBalance } from '@/types/token';
import { KNOWN_TOKENS, SOL_MINT, getTokenMetadata } from '@/constants/tokens';

// Retry configuration
const MAX_RETRIES = 3;
const RETRY_DELAY_MS = 1000;

interface HeliusAsset {
  id: string;
  interface: string;
  content: {
    metadata: {
      name: string;
      symbol: string;
    };
    links?: {
      image?: string;
    };
  };
  token_info?: {
    balance: number;
    decimals: number;
    price_info?: {
      price_per_token: number;
    };
  };
}

/**
 * Sleep utility for retry delays
 */
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Fetch with retry and rate limit handling
 */
async function fetchWithRetry(
  url: string,
  options?: RequestInit,
  maxRetries: number = MAX_RETRIES
): Promise<Response> {
  let lastError: Error | null = null;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await fetch(url, options);

      if (response.status === 429) {
        const retryAfter = response.headers.get('Retry-After');
        const delay = retryAfter ? parseInt(retryAfter) * 1000 : RETRY_DELAY_MS * attempt * 2;
        console.warn(`Rate limited on tokens fetch. Retrying after ${delay}ms...`);
        await sleep(delay);
        continue;
      }

      return response;
    } catch (error) {
      lastError = error as Error;
      if (attempt < maxRetries) {
        const delay = RETRY_DELAY_MS * attempt;
        console.warn(`Token fetch attempt ${attempt} failed. Retrying in ${delay}ms...`);
        await sleep(delay);
      }
    }
  }

  throw lastError || new Error('Token fetch failed after retries');
}

/**
 * Fetch SOL balance with retry
 */
async function fetchSolBalance(publicKey: string): Promise<TokenBalance | null> {
  const connection = getConnection();

  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    try {
      const lamports = await connection.getBalance(new PublicKey(publicKey));
      const solBalance = lamports / LAMPORTS_PER_SOL;

      return {
        mint: SOL_MINT,
        symbol: 'SOL',
        name: 'Solana',
        decimals: 9,
        balance: lamports,
        uiBalance: solBalance,
        usdValue: null,
        logoURI: KNOWN_TOKENS[SOL_MINT]?.logoURI,
        isNative: true,
      };
    } catch (error) {
      console.warn(`SOL balance fetch attempt ${attempt} failed:`, error);
      if (attempt < MAX_RETRIES) {
        await sleep(RETRY_DELAY_MS * attempt);
      }
    }
  }

  console.error('Failed to fetch SOL balance after retries');
  return null;
}

/**
 * Fetch SPL tokens via Helius DAS API
 */
async function fetchSplTokensHelius(publicKey: string): Promise<TokenBalance[]> {
  const apiKey = getHeliusApiKey();
  const network = getNetwork();
  const cluster = network === 'mainnet-beta' ? 'mainnet' : 'devnet';

  const response = await fetchWithRetry(
    `https://${cluster}.helius-rpc.com/?api-key=${apiKey}`,
    {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        id: 'zenwallet',
        method: 'searchAssets',
        params: {
          ownerAddress: publicKey,
          tokenType: 'fungible',
          displayOptions: {
            showNativeBalance: false,
          },
        },
      }),
    }
  );

  if (!response.ok) {
    throw new Error(`Helius API error: ${response.status}`);
  }

  const data = await response.json();

  if (data.error) {
    throw new Error(data.error.message || 'Helius API error');
  }

  const assets: HeliusAsset[] = data?.result?.items || [];
  const balances: TokenBalance[] = [];

  for (const asset of assets) {
    if (!asset.token_info || asset.token_info.balance === 0) continue;

    const knownToken = getTokenMetadata(asset.id);
    const uiBalance = asset.token_info.balance / Math.pow(10, asset.token_info.decimals);

    balances.push({
      mint: asset.id,
      symbol: knownToken?.symbol || asset.content?.metadata?.symbol || 'UNKNOWN',
      name: knownToken?.name || asset.content?.metadata?.name || 'Unknown Token',
      decimals: asset.token_info.decimals,
      balance: asset.token_info.balance,
      uiBalance,
      usdValue: asset.token_info.price_info
        ? uiBalance * asset.token_info.price_info.price_per_token
        : null,
      logoURI: knownToken?.logoURI || asset.content?.links?.image,
    });
  }

  return balances;
}

/**
 * Fetch all balances for a wallet
 */
export async function fetchBalances(publicKey: string): Promise<TokenBalance[]> {
  const balances: TokenBalance[] = [];

  // 1. Get native SOL balance
  const solBalance = await fetchSolBalance(publicKey);
  if (solBalance) {
    balances.push(solBalance);
  }

  // 2. Get SPL tokens via Helius DAS API (if available)
  if (hasHeliusApiKey()) {
    try {
      const splTokens = await fetchSplTokensHelius(publicKey);
      balances.push(...splTokens);
    } catch (error) {
      console.error('Error fetching SPL tokens:', error);
      // Continue without SPL tokens rather than failing completely
    }
  }

  // Sort by USD value (highest first), then by balance
  return balances.sort((a, b) => {
    if (a.isNative) return -1;
    if (b.isNative) return 1;
    if (a.usdValue && b.usdValue) return b.usdValue - a.usdValue;
    if (a.usdValue) return -1;
    if (b.usdValue) return 1;
    return b.uiBalance - a.uiBalance;
  });
}

/**
 * Fetch token prices from Jupiter
 */
export async function fetchTokenPrices(mints: string[]): Promise<Record<string, number>> {
  if (mints.length === 0) return {};

  try {
    const response = await fetchWithRetry(
      `https://price.jup.ag/v6/price?ids=${mints.join(',')}`
    );

    if (!response.ok) {
      throw new Error(`Price API error: ${response.status}`);
    }

    const data = await response.json();

    const prices: Record<string, number> = {};
    for (const [mint, info] of Object.entries(data.data || {})) {
      prices[mint] = (info as { price: number }).price;
    }
    return prices;
  } catch (error) {
    console.error('Error fetching prices:', error);
    return {};
  }
}
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/lib/solana/tokens.ts
```
**Expected Output:**
```
(no output - successful compilation)
```

---

### Task 18: Export New Hooks from Index

**File:** `/Users/lucasbertol/zenwallet/src/hooks/index.ts`
**Action:** Modify

**Current Code:**
```typescript
export { useBalance, useSOLBalance } from './useBalance';
export { useSwap } from './useSwap';
export { useTransaction } from './useTransaction';
export { useClipboard } from './useClipboard';
export { useSessionTimeout } from './useSessionTimeout';
export { usePWAInstall } from './usePWAInstall';
export { useNetworkStatus } from './useNetworkStatus';
```

**New Code:**
```typescript
export { useBalance, useSOLBalance } from './useBalance';
export { useSwap } from './useSwap';
export { useTransaction } from './useTransaction';
export { useTransactionHistory } from './useTransactionHistory';
export { useClipboard } from './useClipboard';
export { useSessionTimeout } from './useSessionTimeout';
export { usePWAInstall } from './usePWAInstall';
export { useNetworkStatus } from './useNetworkStatus';
```

**Verification:**
```bash
cd /Users/lucasbertol/zenwallet && npx tsc --noEmit src/hooks/index.ts
```
**Expected Output:**
```
(no output - successful compilation)
```

---

### Task 19: Run Tests and Commit Batch 4

**Step 1: Run all tests**
```bash
cd /Users/lucasbertol/zenwallet && npm test -- --run
```
**Expected Output:**
```
Test Files  4 passed (4)
```

**Step 2: Build to verify**
```bash
cd /Users/lucasbertol/zenwallet && npm run build
```
**Expected Output:**
```
Build completed successfully
```

**Step 3: Commit changes**
```bash
cd /Users/lucasbertol/zenwallet && git add src/lib/solana/tokens.ts src/hooks/index.ts && git commit -m "feat: add retry logic to token fetching

- Add retry with exponential backoff to token balance fetching
- Handle rate limiting gracefully
- Improve error handling for SPL token fetching
- Export useTransactionHistory from hooks index"
```

---

### CODE REVIEW CHECKPOINT - Batch 4

**Before final verification, run code review as described in Batch 1 checkpoint.**

---

## Failure Recovery

| Issue | Solution |
|-------|----------|
| TypeScript compilation fails | Run `npx tsc --noEmit` to see specific errors. Check import paths match `@/` alias configuration. |
| Tests fail | Run `npm test -- --run` to see failing tests. Check mock setup in tests/setup.ts. |
| Build fails | Run `npm run build` and check for bundle errors. Verify all imports resolve correctly. |
| External wallet signing fails | Verify `walletAdapter.signTransaction` is available. Check wallet is connected. |
| Helius API returns 429 | Rate limiting - retry logic should handle this. Check API key is valid. |
| RPC connection fails | Fallback logic should switch to next RPC. Check network configuration. |
| Transaction history empty | Check if Helius API key is set. Verify address has transaction history on explorer. |
| SPL tokens not showing | Helius API key required for SPL tokens. Check `VITE_HELIUS_API_KEY` is set. |

---

## Final Verification

**Run these commands to verify everything works:**

```bash
# 1. Run all tests
cd /Users/lucasbertol/zenwallet && npm test -- --run

# Expected: All tests pass

# 2. Build for production
npm run build

# Expected: Build completes without errors

# 3. Start development server
npm run dev

# Expected: App starts on localhost:5173

# 4. Manual testing checklist:
# - [ ] Connect Phantom wallet
# - [ ] View balance (SOL and SPL tokens if Helius key set)
# - [ ] Navigate to Activity page (should show transaction history)
# - [ ] Attempt swap (should request wallet signature, not fail with "keypair null")
# - [ ] Attempt send (should request wallet signature)
# - [ ] Disconnect and connect with Solflare
# - [ ] Repeat swap/send tests

# 5. Check git status
git status

# Expected: Working tree clean (all changes committed)

# 6. View commits
git log --oneline -5

# Expected:
# feat: add retry logic to token fetching
# feat: implement transaction history with Helius API fallback
# feat: fix swap and send for external wallets (Phantom/Solflare)
# feat: add unified transaction signing service with RPC fallback
```

---

## Summary of Changes

### Files Created
- `/Users/lucasbertol/zenwallet/src/types/transaction.ts` - Transaction type definitions
- `/Users/lucasbertol/zenwallet/src/lib/solana/transactionService.ts` - Unified transaction signing
- `/Users/lucasbertol/zenwallet/src/lib/helius/historyService.ts` - Transaction history service
- `/Users/lucasbertol/zenwallet/src/hooks/useTransactionHistory.ts` - History hook
- `/Users/lucasbertol/zenwallet/src/pages/Activity.tsx` - Activity page
- `/Users/lucasbertol/zenwallet/tests/solana/transactionService.test.ts` - Transaction service tests
- `/Users/lucasbertol/zenwallet/tests/hooks/useSwap.test.ts` - Swap hook tests

### Files Modified
- `/Users/lucasbertol/zenwallet/src/lib/solana/connection.ts` - Added RPC fallback
- `/Users/lucasbertol/zenwallet/src/lib/jupiter/client.ts` - Return unsigned transactions
- `/Users/lucasbertol/zenwallet/src/lib/solana/tokens.ts` - Added retry logic
- `/Users/lucasbertol/zenwallet/src/hooks/useSwap.ts` - Use unified signing
- `/Users/lucasbertol/zenwallet/src/hooks/useTransaction.ts` - Use unified signing
- `/Users/lucasbertol/zenwallet/src/hooks/index.ts` - Export new hooks
- `/Users/lucasbertol/zenwallet/src/App.tsx` - Add Activity route
- `/Users/lucasbertol/zenwallet/src/components/ui/BottomNav.tsx` - Add Activity nav item

### Key Fixes
1. **P0 - External Wallet Signing**: Now uses `walletAdapter.signTransaction()` for Phantom/Solflare
2. **P0 - Transaction History**: Implemented with Helius API and RPC fallback
3. **P1 - Retry Logic**: All API calls have retry with exponential backoff
4. **P1 - Rate Limiting**: Handles 429 responses gracefully
5. **P1 - RPC Fallbacks**: Connection module supports multiple RPC endpoints
